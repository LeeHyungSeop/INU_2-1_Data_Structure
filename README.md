# INU 2학년 1학기 데이터구조. 핵심 내용 정리

## Recursion ##

## SLL ##
1. 노드 추가
2. 전체 노드 삭제
3. 전체 노드 출력
4. 전체 노드 거꾸로 출력
5. 숫자 하나 없애기
6. 어떤 숫자 앞에 어떤 숫자 삽입
7. 어떤 숫자 뒤에 어떤 숫자 삽입
8. 전체노드 거꾸로 출력

## DLL ##
1. 노드 추가
2. 전체 노드 삭제
3. 전체 노드 출력
4. 숫자 하나 없애기
5. 어떤 숫자 앞에 어떤 숫자 삽입
6. 어떤 숫자 뒤에 어떤 숫자 삽입
7. 전체노드 거꾸로 출력

## stack & queue ##

## stack DLL ##
## Queue DLL ##

## BST ##
1. 노드 추가
2. 노드 찾기
2. 총 노드의 개수
3. terminal 노드의 개수
4. height
5. BST 전체 출력 (inorder,preorder,postorder)
6. 노드 삭제

## Heap ##

## 정렬 ##
1. 선택정렬
2. 삽입
3. 버블
4. 셸
5. merge
6. quick

## 그래프 ##
1. DFS
2. BFS

## Minimum Spanning Tree ##
addEdge(graph, 0, 1, 100);
	addEdge(graph, 0, 2, 10);
	addEdge(graph, 1, 2, 1);
	addEdge(graph, 1, 3, 1);
	addEdge(graph, 1, 4, 15);
	addEdge(graph, 2, 3, 1);
	addEdge(graph, 3, 4, 1);
1. Prim algorithm
2. Kruskal algorithm


## 최단경로 ##
1. Dijkstra algorithm
int graph[NV][NV] = {
		//   0   1  2  3  4  5  6
			{-1,-1,-1,-1,-1,-1,-1}, // 0
			{-1,-1,3,-1,15,-1,-1}, // 1
			{-1,3,-1,30,2,-1,-1}, // 2
			{-1,-1,30,-1,-1,3,4}, // 3
			{-1,15,2,-1,-1,1,-1}, // 4 
			{-1,-1,-1,3,1,-1,20}, // 5
			{-1,-1,-1,4,-1,20,-1}, // 6
	};
2. Ford algorithm
int graph[NV][NV] = {
		{9999,4,1,9999,9999,9999,9999},
		{4,9999,3,9999,15,9999,9999},
		{1,3,9999,30,2,9999,9999},
		{9999,9999,30,9999,9999,3,4},
		{9999,15,2,9999,9999,1,9999},
		{9999,9999,9999,3,1,9999,20},
		{9999,9999,9999,4,9999,20,9999}
	};

## Topological sort ##
int graph[NV][NV] = {

		{0,0,1,1,0,0},    // 0에서 2가는 edge, 0에서 3가는 edge
		{0,0,0,1,1,0},	  // 1에서 3가는 edge, 1에서 5가는 edge
		{0,0,0,0,0,1},
		{0,0,0,0,0,1},
		{0,0,0,0,0,1},	  // 4에서 5가는 edge
		{0,0,0,0,0,0}	  // 5에서 가는 edge는 없다

	};

## Hashing ##
1. 노드추가
2. 노드 제거
3. 노드 검색
4. hash table display
--------------------------------------------

## 20_Mouse_to_Cheese_HomeWork.c

* 쥐가 치즈를 최단 경로로 찾아가는 문제 (Dijsktra algorithm)
![](./20.gif)